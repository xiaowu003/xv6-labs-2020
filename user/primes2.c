//自己完成的代码
#include "kernel/types.h"
#include "user/user.h"

#define RD 0		//每个管道的读端
#define WR 1		//每个管道的写端

struct pipe_process_st {
    //每个进程都会有的一个结构体
    int lpipe[2];	//左管道，即父进程给子进程传递信息的管道
    int rpipe[2];	//右管道，即子进程给孙进程传递信息的管道
    int child_pid;              //the pid of the child process generated by a process
    int process_generation;     //sequence number of process
    int buf;		//用来存放每个进程接收的第二个及以后得数据的变量，每次只有一个数值
    int first;		//用来存放每个进程接收的第一个数据的变量
    int pipe_flag;	//是否进行过创建pipeline，用来控制每个进程只创建一个pipeline
};

void primes(struct pipe_process_st *pp_st);

int main(int argc, char const *argv[]) {

    struct pipe_process_st pp_st;		//创建结构体
    pp_st.process_generation = 1;		//初始进程为第一代进程
    pipe(pp_st.lpipe);					//对于初始进程不存在左管道，但为了让第一个子进程获得管道信息，将其放在左管道，相应的第一个进程的rpipe则不再使用

    for (int i = 2; i <= 35; ++i) {
        //一次性将所有数据写入管道传给第一个子进程
        if ( write(pp_st.lpipe[WR], &i, sizeof(int)) != sizeof(int) ) {
            //写入错误提示
            fprintf(2, "Initial write() failed.\n");
        }
    }

    //fork创建子进程，此时子进程也会有一份pp_st结构体，它的lpipe刚好成为了和父进程通信的管道
    if ( fork() == 0 ) {
        //子进程进入递归
        primes(&pp_st);
    } else {
        //父进程的写入任务已经完成，关闭所有管道文件描述符，不关闭会导致资源不够用
        close(pp_st.lpipe[WR]);
        close(pp_st.lpipe[RD]);
        //要求所有子进程退出后初始进程才能退出，所以在这里wait
        wait(0);
    }

    exit(0);
}

void primes(struct pipe_process_st *pp_st) {
    close(pp_st->lpipe[WR]);			//关闭子进程与父进程沟通的写入端，它只需要读数据
    pp_st->process_generation += 1;		//进程代数加1
    int ret = read(pp_st->lpipe[RD], &pp_st->first, sizeof(int));	//读取第一个数据，赋值给first，read返回值给ret用来判断是否出错，以及判断是否全部读取完毕（ret=0时，说明全部读取完毕）
    if ( ret != sizeof(int) ) {
        if (ret != 0) {
            fprintf(2, "the %dth process read() failed.\n", pp_st->process_generation);
            exit(1);
        }
        //当ret=0是，读取任务结束，同时写入下一管道的任务同时也完成（因为是读一个写一个），退出
        exit(0);
    } else {
        printf("primes %d\n", pp_st->first);		//完成输出任务
    }

    while ( read(pp_st->lpipe[RD], &pp_st->buf, sizeof(int)) == sizeof(int) ) {	//依次读取第二个及以后的数据
        if ( pp_st->buf % pp_st->first ) {		//判断是否能够被first整除
            if (pp_st->pipe_flag == 0) {		//判断该进程是否已经创建过pipeline
                pipe(pp_st->rpipe);
                pp_st->pipe_flag = 1;
            }
            if ( write(pp_st->rpipe[WR], &pp_st->buf, sizeof(int)) != sizeof(int) ) {	//将数据写入当前子进程的右管道
                fprintf(2, "the %dth process write() failed.\n", pp_st->process_generation);
            }
        }
    }

    if ( fork() == 0) {	//fork产生子进程
        pp_st->lpipe[RD] = pp_st->rpipe[RD];	//对于子进程来说，原来的rpipe是它和父进程通信的管道，lpipe是和爷进程通信的管道(并不需要这个)，所以将rpipe赋值给lpipe，保持所有子进程都是通过lpipe与它的父进程同信
        pp_st->lpipe[WR] = pp_st->rpipe[WR];
        pp_st->pipe_flag = 0;					//新子进程的创建pipieline标识清零
        primes(pp_st);							//递归调用
    } else {
        close(pp_st->lpipe[RD]);				//当前的父进程完成所有任务，关闭所有剩下的管道读写端，并wait
        close(pp_st->rpipe[RD]);
        close(pp_st->rpipe[WR]);
        wait(0);
    }

    exit(0);
}